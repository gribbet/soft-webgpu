(function(){const a=document.createElement("link").relList;if(a&&a.supports&&a.supports("modulepreload"))return;for(const e of document.querySelectorAll('link[rel="modulepreload"]'))r(e);new MutationObserver(e=>{for(const o of e)if(o.type==="childList")for(const s of o.addedNodes)s.tagName==="LINK"&&s.rel==="modulepreload"&&r(s)}).observe(document,{childList:!0,subtree:!0});function t(e){const o={};return e.integrity&&(o.integrity=e.integrity),e.referrerPolicy&&(o.referrerPolicy=e.referrerPolicy),e.crossOrigin==="use-credentials"?o.credentials="include":e.crossOrigin==="anonymous"?o.credentials="omit":o.credentials="same-origin",o}function r(e){if(e.ep)return;e.ep=!0;const o=t(e);fetch(e.href,o)}})();const u=(n,a,t)=>{const r=n.createBuffer({size:t.byteLength,usage:a|GPUBufferUsage.COPY_DST,mappedAtCreation:!0}),e=t instanceof Uint32Array?Uint32Array:Float32Array;return new e(r.getMappedRange()).set(t),r.unmap(),r},G=(n,a,t)=>n.createBindGroup({layout:a.getBindGroupLayout(0),entries:t.map((r,e)=>({binding:e,resource:{buffer:r}}))}),I=[[-1,-1],[1,-1],[-1,1],[1,1]],N=async({device:n,format:a,aspectBuffer:t,boundaryBuffer:r})=>{const e=u(n,GPUBufferUsage.STORAGE,new Float32Array(I.flat())),o=n.createShaderModule({code:await(await fetch("background.wgsl")).text()}),s=n.createRenderPipeline({layout:"auto",vertex:{module:o,entryPoint:"vertex"},fragment:{module:o,entryPoint:"fragment",targets:[{format:a}]},primitive:{topology:"triangle-strip"}}),c=G(n,s,[t,e,r]);return{encode:i=>{i.setPipeline(s),i.setBindGroup(0,c),i.draw(4)}}},B=64,E=8,T=.25,v=.5,_=.025,f=Math.floor(T/_),M=Math.floor(v/_),m=new Array(M+1).fill(0).flatMap((n,a)=>new Array(f+1).fill(0).map((t,r)=>[T*(r/f-.5),v*(a/M-.5)])),O=new Array(f).fill(0).flatMap((n,a)=>new Array(M).fill(0).flatMap((t,r)=>[[r*(f+1)+a,r*(f+1)+a+1,(r+1)*(f+1)+a+1],[r*(f+1)+a,(r+1)*(f+1)+a+1,(r+1)*(f+1)+a]])),q=B*Math.ceil(m.length/B),h=new Float32Array(q*2);h.set(new Float32Array(m.flat()));const k=new Uint32Array(O.flat()),z=m.reduce((n,a,t)=>{const r=O.filter(o=>o.includes(t)).map(([o,s,c])=>o===t?[s,c]:s===t?[c,o]:[o,s]),e=[];for(;;){const o=r.pop();if(!o)break;const[s,c]=o;e.length===0?e.push(s,c):e[0]===c?e.splice(0,0,s):e[e.length-1]===s?e.push(c):r.unshift(o)}return n[t]=e,n},{}),R=new Uint32Array(q*E*2);R.fill(4294967295);R.set(m.flatMap((n,a)=>{const t=z[a]??[];return new Array(E).fill(0).flatMap((r,e)=>[(e===0||t[e]!==t[0]?t[e]:void 0)??4294967295,t[e+1]??4294967295])}));const C=n=>new Float32Array(new Array(5).fill(0).map((a,t,{length:r})=>{const e=n/2e3+2*(t*Math.PI)/r;return{normal:[Math.cos(e),Math.sin(e)],offset:-.5}}).flatMap(({normal:[a=0,t=0],offset:r})=>[a,t,r,0])),W=async({device:n,positionBuffer:a,forceBuffer:t})=>{const r=u(n,GPUBufferUsage.STORAGE,h),e=u(n,GPUBufferUsage.STORAGE,R),o=n.createShaderModule({code:await(await fetch("forces.wgsl")).text()}),s=n.createComputePipeline({layout:"auto",compute:{module:o,entryPoint:"main"}}),c=G(n,s,[r,a,e,t]);return{encode:i=>{const l=i.beginComputePass();l.setPipeline(s),l.setBindGroup(0,c);const y=Math.ceil(m.length/B);l.dispatchWorkgroups(y),l.end()}}},Y=async({device:n,positionBuffer:a,boundaryBuffer:t,forceBuffer:r})=>{const e=u(n,GPUBufferUsage.UNIFORM,new Float32Array([0])),o=u(n,GPUBufferUsage.STORAGE,h),s=n.createShaderModule({code:await(await fetch("integrate.wgsl")).text()}),c=n.createComputePipeline({layout:"auto",compute:{module:s,entryPoint:"main"}}),p=G(n,c,[e,t,a,o,r]);return{encode:(l,y)=>{n.queue.writeBuffer(e,0,new Float32Array([y]));const w=l.beginComputePass();w.setPipeline(c),w.setBindGroup(0,p);const U=Math.ceil(m.length/B);w.dispatchWorkgroups(U),w.end()}}},K=async({device:n,format:a,aspectBuffer:t,positionBuffer:r})=>{const e=u(n,GPUBufferUsage.STORAGE,k),o=n.createShaderModule({code:await(await fetch("render.wgsl")).text()}),s=n.createRenderPipeline({layout:"auto",vertex:{module:o,entryPoint:"vertex"},fragment:{module:o,entryPoint:"fragment",targets:[{format:a}]},primitive:{topology:"triangle-list"}}),c=G(n,s,[t,r,e]);return{encode:i=>{i.setPipeline(s),i.setBindGroup(0,c),i.draw(3,O.length,0,0)}}},V=async()=>{const{gpu:n}=navigator,a=await n.requestAdapter();if(!a)throw new Error;const t=await a.requestDevice(),{queue:r}=t,e=document.createElement("canvas");document.body.appendChild(e);const o=e.getContext("webgpu");if(!o)throw new Error;const s=n.getPreferredCanvasFormat();o.configure({device:t,format:s});const c=u(t,GPUBufferUsage.UNIFORM,new Float32Array([1])),p=u(t,GPUBufferUsage.STORAGE,h),i=u(t,GPUBufferUsage.STORAGE,C(0)),l=u(t,GPUBufferUsage.STORAGE,h.map(()=>0)),y=await W({device:t,positionBuffer:p,forceBuffer:l}),w=await Y({device:t,positionBuffer:p,boundaryBuffer:i,forceBuffer:l}),U=await N({device:t,format:s,aspectBuffer:c,boundaryBuffer:i}),L=await K({device:t,format:s,aspectBuffer:c,positionBuffer:p});new ResizeObserver(([d])=>{const{width:P=0,height:g=0}=(d==null?void 0:d.contentRect)??{};e.width=P*devicePixelRatio*2,e.height=g*devicePixelRatio*2;const A=P/g;t.queue.writeBuffer(c,0,new Float32Array([A]))}).observe(e);let F;const S=d=>{requestAnimationFrame(S);const P=(d-(F??d))/1e3;F=d,r.writeBuffer(i,0,C(d));const g=t.createCommandEncoder(),A=50;for(let x=0;x<A;x++)y.encode(g),w.encode(g,P/A);const D=o.getCurrentTexture().createView(),b=g.beginRenderPass({colorAttachments:[{view:D,loadOp:"clear",storeOp:"store"}]});U.encode(b),L.encode(b),b.end(),r.submit([g.finish()])};requestAnimationFrame(S)};V();
